// SPDX-License-Identifier: MIT
pragma solidity ^0.8.25;

import "../IBitcoinVault.sol";
import "./SimpleGlobalVaultConfig.sol";
import "../VaultUtils.sol";
import "./SimpleBitcoinVaultState.sol";
import "../../BitcoinTunnelManager.sol";
import "../../oracles/IAssetPriceOracle.sol";
import "../../BTCToken.sol";
import "./SimpleBitcoinVaultStructs.sol";

/**
* [SUMMARY]
* The SimpleBitcoinVault is a vault which custodies BTC across multiple UTXOs held
* by a single Bitcoin address.
*
* Periodically, the operator sweeps deposits together into a single UTXO, such that
* that the single UTXO can be used for processing withdrawals with a predictable transaction
* size, and the operators can time sweeps which are not as time-sensitive as withdrawals
* around preferable Bitcoin fee market times.
* 
* Each SimpleBitcoinVault is collateralized and secured by a single operator, who 
* competes with other SimpleBitcoinVault operators to provide deposits and withdrawals
* at competitive rates. Operators can set and modify deposit and withdrawal fees
* dynamically to adjust to the overall supply vs demand market for deposits and 
* withdrawals, within certain thresholds maintained by the protocol itself.
*
* SimpleBitcoinVault collateralization is dynamic - operators are free to increase
* or decrease their collateral so long as minimum collateral thresholds for custodied
* assets are maintained.
*
* When a SimpleBitcoinVault's collateral falls below the liquidation threshold,
* their collateral is seized by the protocol and used to repurchase and burn the
* BTC custodied by the vault on behalf of the protocol to ensure solvency. The end
* result of liquidation of a SimpleBitcoinVault is the operator loses the collateral
* which was required to repurchase and burn the appropriate quantity of hBTC to remove
* the vault from actively representing BTC custodianship for the protocol, and the
* operator receives back the remaining unused collateral and keeps the Bitcoin stored
* in the custodianship wallet they control.
*
* Vaults are also liquidated for misbehavior, such as unauthorized withdrawals or
* failure to process a specific withdrawal within the specified timeframe.
* 
* It is possible for users to accidentally send funds to the vault in a way which
* does not correlate with a valid deposit. Depending on the type of mistake, attempts
* will be made automatically by the protocol to return the funds (minus fees) to the
* sender, however this will not be possible in all scenarios.
*
* It is the responsibility of users to interact with the SimpleBitcoinVault correctly,
* meaning: 
*   - Transaction contains an OP_RETURN that encodes their EVM address for minting hBTC,
*     and this OP_RETURN output is the first OP_RETURN output in the transaction.
*   - Transaction deposit output must be above the minimum deposit threshold
*   - Transaction does not deposit more BTC than the vault's collateral can handle
*   - OP_RETURN and output to the vault is within the first 16 outputs
*
*
* [INVALID DEPOSIT RETURN SYSTEM]
* A quantity of Bitcoin may be sent to the Vault's custodianship address in a way
* which does not result in a successful deposit.
*
* This failure can occur for two reasons:
*   1. Deposit transaction is invalid in some way
*   2. Deposit transaction is invalid but accepting it would violate the Vault's
*       collateralization requirements.
*
* When this does occur, the protocol attempts to process a "Bounce" to return the funds.
* If the failed transaction can be associated with an EVM address that the depositor
* intended for the funds to be credited to, a ClaimableBounce is created, which the EVM
* address the deposit would have been credited to can use to direct where the return
* should be sent within 12 hours.
*
* If the EVM address claims the ClaimableBounce within 12 hours, it specifies where
* the funds (minus fees) should be sent, which converts the ClaimableBounce to a Bounce
* which the operator is then required to process.
*
* If either a deposit attempt does not have a corresponding EVM address extractable
* from an OP_RETURN or the EVM address does not claim the ClaimableBounce within the
* required time period, the protocol automatically creates a Bounce to return funds to
* the original unlocking script of the largest input in the first 16 inputs of the
* invalid deposit that has an unlock script within the normal withdrwal unlock script
* size limitations.
* 
* When processing a Bounce (whether one generated by the protocol automatically or
* one generated by a permitted EVM address claiming a ClaimableBounce), the operator
* processes it similar to a sweep, except only the fees collected by the operator
* are swept into the primary UTXO and another output is created which returns the
* remainder of the funds to the determined recipient script of the Bounce.
*
* For example:
* A transaction is processed on Bitcoin which sends 1 BTC to the Vault's custodianship
* address, and looks like:
*
* ------------------------------------------------------------------------------------
* |                      DEPOSIT TRANSACTION (TxID=419f...3164)                      |
* ------------------------------------------------------------------------------------
* |                 INPUTS                 |                 OUTPUTS                 |
* ------------------------------------------------------------------------------------
* | Input: a1c3...88de:3                   | ScriptSig: <VaultOperator>              |
* | Value: 0.400 BTC                       | Value: 1.000 BTC                        |
* ------------------------------------------------------------------------------------
* | Input: b552...61ad:0                   | ScriptSig: <SenderChangeScript>         |
* | Value: 0.801 BTC                       | Value: 0.200 BTC                        |
* ------------------------------------------------------------------------------------
* (fee paid for original deposit: 0.001 BTC)
*
* This transaction would be invalid (regardless of available Vault collateral) because it
* does not have an OP_RETURN output which specifies an EVM address to credit. As a result,
* the protocol automatically converts it to a Bounce.
*
* The protocol will choose the 2nd input (b552...61ad:0) to use as the return destination,
* assuming that the original unlocking script in b552...61ad output 0 is within the standard
* withdrawal destination script size bounds.
*
* If the minimum deposit fee of the vault is 0.002 BTC, then the Bounce will return 
* the amount sent to the vault (1.000 BTC) minus the fee (0.002 BTC) = 0.998 BTC back to
* the original unlock script of Transaction b552...61ad output 0.
*
* When the operator processes this Bounce, they will sweep the fees to the primary
* custodianship UTXO (which for example purposes has 2.000 BTC currently):
*
* ------------------------------------------------------------------------------------
* |                                BOUNCE TRANSACTION                                |
* ------------------------------------------------------------------------------------
* |                 INPUTS                 |                 OUTPUTS                 |
* ------------------------------------------------------------------------------------
* | Input: 419f...3164:0 (dep tx)          | ScriptSig: <VaultOperator>              |
* | Value: 1.000 BTC                       | Value: 2.001 BTC                        |
* ------------------------------------------------------------------------------------
* | Input: <VaultPrimaryUtxo>              | ScriptSig: b552...61ad:0 orig script    |
* | Value: 2.000 BTC                       | Value: 0.998 BTC                        |
* ------------------------------------------------------------------------------------
* (operator paid 0.001 BTC to get bounce tx processed on Bitcoin, so collected 0.001 BTC
* in net fees).
*
*
* [VAULT SETUP PROCESS]
* Anyone can set up a SimpleBitcoinVault (assuming no global vault creation pause or
* whitelisting is temporarily enabled at the BitcoinTunnelManager level) through the
* BitcoinTunnelManager.
*
* Deploying the SimpleBitcoinVault through the BitcoinTunnelManager is required for the
* vault to be recognized by the Bitcoin Tunnel protocol and usable.
*
* The setup steps are as follows:
*   1. Call createVault() on the BitcoinTunnelManager with appropriate arguments
*   2. Deposit sufficient collateral in the recognized ERC20 collateral token into the new vault
*   3. Configure the vault with a new Bitcoin address that the operator holds the private key for
*   4. Set initial parameters for deposit and withdrawal fees as desired
*   5. When ready to begin processing deposits and withdrawals, change the vault status to LIVE
*
*
* [VAULT MANAGEMENT PROCESS]
* Once a Vault is live, the operator is responsible for performing the following duties:
*   1. Maintaining a sufficient collateral threshold at all times (or face liquidation)
*   2. Process withdrawals in a timely manner
*   3. Actively modify deposit and withdrawal fees as desired, to ensure that enough fees
*      are charged to properly account for on-chain fees the operator will have to pay at
*      a minimum (or face partial liquidation seizure)
*
* The Vault can continue operating indefinitely so long as the operator behaves appropriately,
* unless the SimpleBitcoinVault custodianship system is phased out by the protocol at which point
* the Vault will no longer accept deposits and can only process withdrawals.
*
* By operating the Vault, the operator will collect fees charged on deposits and withdrawals
* which are accounted for in a fee collection account, which the operator can claim by
* minting the corresponding hBTC through the BitcoinTunnelManager.
*
*
* [VAULT CLOSURE PROCESS]
* If an operator desires to spin down their Vault, they can set their Vault to CLOSING_INIT mode
* which will block future deposits, turning the vault into a withdrawal-only mode.
*
* Additionally, the operator can unwind their vault more quickly by providing the equivalent
* hBTC that their Vault still represents custodianship for, which is burnt and the operator can
* then withdraw their full collateral and keep the equivalent BTC remaining in the custodianship
* address they used.
*
*
* [COLLATERALIZATION SYSTEM]
* Each Vault is collateralized by its respective operator with a quantity of the approved ERC20
* token. Vault operators can deposit additional collateral or withdraw excess collateral at any
* time.
*
* The value of the collateral versus the custodied BTC is determined by an Oracle, which is
* an implementation of the IAssetPriceOracle which is configured in the SimpleGlobalVaultConfig,
* meaning that the same Oracle implementation (and thus, price feeds) are used by all
* SimpleBitcoinVaults.
*
* There are two collateralization thresholds:
*   1. The "soft collateralization threshold", below which no additional deposits can be accepted
*      (and any attempted deposits will be rejected and the operator will be required to send
*      the deposit back to the originator minus fees)
*   2. The "hard collateralization threshold", below which the vault is subject to liquidation.
*
* The soft collateralization threshold is by default set to the maximum allowed value at vault
* construction, which is provided by the SimpleGlobalVaultConfig and used by the 
* SimpleBitcoinVaultFactory. Operators can optionally choose to increase this threshold to protect
* against liquidations.
*
* For example, if the minimum soft collateralization threshold is 140, then an operator could set
* it to 150, and deposits would not be accepted when the deposit would increase the value of
* BTC custodied by the vault such that the value of the collateral is less than 150% that of the
* BTC custodied.
*
* The hard collateralization threshold is set to a single value provided by the SimpleGlobalVaultConfig
* and cannot be changed by the operator.
*
* 
* [VAULT LIQUIDATION PROCESS]
* When a Vault falls below the hardCollateralizationThreshold, the vault is immediately subject
* to full liquidation. Anyone can begin the vault liquidation process if the vault's collateral
* value is less than the hardCollateralizationThreshold multiplied by the BTC custodied by
* the vault. A vault is also eligible for liquidation when the operator misbehaves by failing to
* process a withdrawal within the requested time.
*
* The full liquidation process is an ascending auction where anyone can sell hBTC for the
* underlying collateral at the current rate offered, and the current rate increases over time.
*
* The rate starts at 5% higher than the value of the collateral based on the oracle and then
* is continually increased.
*
* Because the vault does not know about pending deposits that have not yet been confirmed,
* additional deposits to the vault are permitted during the first 4 hours of liquidation and the 
* depositor will be credited with the appropriate hBTC if their deposit is otherwise valid and 
* doesn't cause the vault to exceed the soft collateralization threshold as usual (only applies 
* when vault is being liquidated due to operator misbheavior rather than collateralization).
*
* If additional deposits to the vault are confirmed during the liquidation process, the amount
* of hBTC needing to be liquidated will be increased. This can result in selling collateral for
* higher than usual, but is limited to the increase in price during the first 4 hours of
* liquidation, after which new deposits cannot be accepted.
*
* The liquidation process is considered finished when 4 hours pass (meaning no more deposits
 can come in) and the vault has recovered all of the hBTC it needs to recover.  
*
* After the full liquidation is complete, the operator can withdraw any remaining collateral which
* wasn't sold off, and also owns all of the native BTC left in the custody address.
*
* During the full liquidation process, the operator can also deposit the full amount of hBTC required
* to end the liquidation process immediately and recover their entire collateral.
*
* When an operator reports a sweep or withdrawal transaction that paid on-BTC fees higher than
* the fees collected from the user, the difference is subtracted from the operator's collected
* but unclaimed fees. If the operator's collected but unclaimed fees are not sufficient, then
* a partial liquidation is immediately triggered, starting by offering 2x the amount of collateral
* which should be required based on the price oracle to unwind the BTC:hBTC discrepancy.
*
* Similar to the full liquidation procedure, the operator can provide the required amount of hBTC
* to immediately close out the partial liquidation process.
*
*
* [INCENTIVE MECHANISMS]
* Operators are incentivized by the fees that they can collect on deposits and withdrawals,
* and incentives are aligned such that they maximize revenue by competing with other operators
* to offer the lowest fees to users.
*
* Operators are disincentivized from stealing assets because the collateral they post is worth
* more than the BTC that they custody on behalf of the protocol during normal operation.
* Operators are incentivized to maintain appropriate collateral ratios, because liquidations 
* will generally result in the operator losing some amount of value.
*
* Liquidators are incentivized by the opportunity to purchase assets at a discount in exchange
* for de-risking the protocol. Liquidators submit irrevocable bids in a reverse auction, which
* minimizes the value that operators lose while ensuring that as soon as a bid is received, the
* vault is effectively de-risked.
*
*
* [VAULT ACCOUNTING]
* The Vault maintains accounting for:
*   - The total BTC the vault is custodying on behalf of the protocol
*   - The total operator fees collected which have not been claimed
*
* The total BTC that the vault is custodying on behalf of the protocol represents the total
* circulating supply of hBTC in circulation which is backed by BTC held by the Vault.
* It is the sum of all deposits (minus fees) minus withdrawals (minus fees) plus fees withdrawn
* by the operator as hBTC.
*
* For example:
*   1. Vault is initialized, holds 0 BTC and 0 collected fees
*   2. User deposits 0.1 BTC, and 0.001 is charged in fees. User mints 0.099 hBTC, and the total
*      hBTC represented by vault is 0.099 hBTC. There are 0.001 BTC in pending fees.
*   3. ANother user deposits 0.2 BTC, and 0.002 is charged in fees. User mints 0.198 hBTC, and the
*      total hBTC represented by vault is 0.297 hBTC. There are 0.003 BTC in pending fees.
*   4. Operator processes the deposit sweep of both deposits, paying a total of 0.0005 in on-chain
*      fees, and operator now has 0.003-0.0005=0.0025 BTC in collected but unclaimed fees.
*      At this point, the Vault represents 0.297 hBTC in circulation, which is the vault
*      custodianship value used for determining appropriate collateralization. The actual balance
*      (sum of all UTXOs) of the Vault is 0.297+0.0025=0.2995 BTC, but 0.0025 of that is the
*      Operator's, so is not of concern to the protocol from a custodianship security perspective.
*   5. Operator mints hBTC representing their 0.0025 BTC in collected fees, at which point the
*      Vault is now custodying 0.2995 BTC which is backing circulating hBTC, and this value is
*      now used for determining appropriate collateralization. Operator has 0 pending collected
*      but unclaimed fees.
*   6. User submits a withdrawal for 0.15 BTC by burning 0.15 hBTC, and a pending fee for the
*      withdrawal of 0.0015 BTC will be charged so user expects to receive 0.15-0.0015=0.1485
*      BTC to their withdrawal address. Vault still holds 0.2995 BTC on behalf of the protocol, as
*      the withdrawal has not been processed yet, and this value is still used for collateralization.
*   7. Operator processes withdrawal, sending 0.1485 BTC and paying 0.0005 in on-chain fees. After
*      proving the withdrawal to the vault, the Vault holds 0.2995-0.15=0.1495 BTC on behalf of
*      the protocol, and the operator has 0.0015-0.0005=0.001 BTC in collected but unclaimed fees.
*
* Deposits are not counted towards the Vault's custodied balance until the deposit is claimed and
* the corresponding hBTC is minted. Withdrawals continue to be counted towards the Vault's custodied
* balance until the withdrawal transaction is proven to the vault.   
*
* 
* [PERMISSIONED ADDRESSES]
* There are two addresses which play important roles in the operation of a SimpleBitcoinVault:
*   - The tunnelAdmin is the BitcoinTunnelManager which deployed the SimpleBitcoinVault, and
*     is the only actor able to call deposit and withdrawal related functions. Users call 
*     deposit and withdrawal functions on the Vault via the BitcoinTunnelManager. All liquidation
*     actions also go through the BitcoinTunnelManager, but the address of the original caller
*     is passed through, so that special treatment during the liquidation process can be given
*     to the operatorAdmin.
*   - The operatorAdmin is the EVM address of the operator who deposits collateral and maintains
*     the required collateral ratio, and submits proof of sweep and withdrawal transactions directly
*     to the vault.
*
*
* [DEPOSIT AND WITHDRAWAL FEES]
*
* As it costs BTC to perform these sweep transactions, each deposit is charged a fee,
* which is held in a "virtual accounting escrow" until the sweep occurs, at which time
* the actual cost (in sats) of the sweep transaction is removed from the virtual escrow
* and the remainder is released to the operator's virtual revenue.
*
* Because the cost to process the sweep on Bitcoin is unrelated to the size of the deposit,
* but larger deposits consume more of the operator's collateral, fees are charged in a
* 2-step system which takes both costs into account.
*
* The operator of each vault sets two values (within min/max bounds enforced across all
* instances of the SimpleBitcoinVault deployed):
*   - minDepositFee (the minimum fee in sats that all deposits will be charged)
*   - depositFeeBps (the fee in bps that a deposit will be charged)
*
* And the actual fee collected from each deposit will be the higher of minDepositFee or
* the deposit's size multiplied by the bps cost.
*
* For example: 
*   - The SimpleGlobalVaultConfig has a min deposit fee of 10,000 sat and max of 200,000 sat
*   - The SimpleGlobalVaultConfig as a min bps of 20 (0.2%) and 100 (1%)
*   - The operator set a min deposit fee of 25,000 sat (0.00025 BTC) which is within bounds
*   - The operator sets a deposit bps fee of 30 (0.3%) which is within bounds
*   - Therefore, a deposit of 100,000 sat will incur an effective 25% fee (because of the 
*     minimum fee charged), and a deposit of 10,000,000 sat will incur an effective
*     0.3% fee (because the bps fee of 30,000 sat is higher than the min deposit fee)
*
* Because users will make deposits that take time to confirm on Bitcoin, increases to
* either the minDepositFee or depositFeeBps will take 4 hours to go into effect, ensuring
* depositors receive the fee treatment they expected for their deposit as long as they
* pay the appropriate Bitcoin transaction fees on their end to have their transaction included
* in the Bitcoin blockchain in a timely manner.
*
* A similar mechanic is used for withdrawals, with minWithdrawalFee and withdrawalFeeBps.
*
* Because it is expected that multiple vaults will be competing for traffic from users
* in both the deposit and withdrawal market, allowing these two rates to be different
* should not create "ransom" scenarios (depsoits are cheap but withdrawals are expensive
* and that withdrawal fee is laid off on the user who ends up with the hBTC in the end)
* because operators are openly competing with each other for both deposits and withdrawals.
*
* The end economic scenario should be that the cost charged by operators for deposits
* and withdrawals aligns with the different economic costs associated with them and
* the demand imbalance between deposits (requiring collateralization commitment) and
* withdrawals (which free up collateral).
*/

contract SimpleBitcoinVault is IBitcoinVault, VaultUtils, SimpleBitcoinVaultStructs {
    event CollateralDeposited(uint256 indexed amountDeposited, uint256 indexed totalCollateral);
    event CollateralWithdrawn(uint256 indexed amountWithdrawn, uint256 indexed totalCollateral);

    event VaultLive();

    event PartialLiquidationStarted(uint256 satsToRepurchase, uint256 startingBid);

    event FullLiquidationStarted(uint256 satsToRepurchase, uint256 startingPrice);

    /**
    * The onlyTunnelAdmin modifier is used on all functions that should
    * *only* be callable by the tunnelAdmin.
    */
    modifier onlyTunnelAdmin() {
        require(msg.sender == tunnelAdmin);
        _;
    }

    /**
    * The onlyOperatorAdmin modifier is used on all functions that should
    * *only* be callable by the operatorAdmin.
    */
    modifier onlyOperatorAdmin() {
        require(msg.sender == operatorAdmin);
        _;
    }

    /**
    * The onlyOperatorAdminPassthrough modifier is used on all functions that
    * should *only* be callable by the tunnelAdmin who passes through the
    * original caller which should *only* be the operatorAdmin.
    */
    modifier onlyOperatorAdminPassthrough(address passthroughAddr) {
        require(msg.sender == tunnelAdmin);
        require(passthroughAddr == operatorAdmin);
        _;
    }

    /**
    * The notZeroAddress modifier is used on all functions where a check that an
    * address argument is not the zero address.
    */
    modifier notZeroAddress(address addr) {
        require(addr != address(0));
        _;
    }

    struct PartialLiquidation {
        uint256 amountSatsToRecover;
        uint256 startTimestamp;
        uint256 currentBidAmount;
        uint256 currentBidTime;
        address currentBidder;
        bool finished;
    }

    // Limit the maximum number of pending withdrawals allowed, to limit worst-case
    // gas costs when analyzing the entire withdrawal queue is required
    // (ex: confirming that a withdrawal is malicious and does not pay out
    // to any of the expected pending withdrawal lock scripts).
    uint256 public constant MAX_WITHDRAWAL_QUEUE_SIZE = 5;

    // How long the operator has to process a withdrawal before vault is subject to full liquidation
    uint256 public constant WITHDRAWAL_GRACE_PERIOD_SECONDS = 60 * 60 * 12; // 12 hours

    // Minimum deposit of 0.01 BTC
    uint256 public constant MINIMUM_DEPOSIT_SATS = 1000000;

    // Minimum withdrawal of 0.01 BTC
    uint256 public constant MINIMUM_WITHDRAWAL_SATS = 1000000;

    // Minimum valid script size is first line of defense against invalid scripts
    uint256 public constant MIN_VALID_BTC_SCRIPT_SIZE = 20;

    // Maximum valid script size prevents unreasonably long spend scripts
    uint256 public constant MAX_VALID_BTC_SCRIPT_SIZE = 64;

    // Time in seconds after a full liquidation is started after which deposits are not accepted
    uint256 public constant FULL_LIQUIDATION_DEPOSIT_GRACE_PERIOD = 60 * 60 * 4; // 4 hours

    // Time in seconds for a partial liquidation bid to survive being out-bid to be accepted
    uint256 public constant PARTIAL_LIQUIDATION_BID_TIME = 60 * 15; // 15 minutes

    // During a full liquidation, how often to increase the price (linear increase)
    uint256 public constant FULL_LIQUIDATION_INCREASE_TIME = 60; // 60 seconds

    // Increase by 0.03% every increment. At 60 seconds per increment, that's 1.8% per hour.
    uint256 public constant FULL_LIQUIDATION_INCREASE_INCREMENT_BPS = 3; 

    // How long the operator has to wait between initiating and finalizing a partial collateral withdrawal
    uint256 public constant PARTIAL_COLLATERAL_WITHDRAWAL_DELAY = 60 * 60 * 4; // 4 hours

    // How long after initiating wind-down procedures until the vault enters CLOSING_INIT state
    uint256 public constant WIND_DOWN_DEPOSIT_GRACE_PERIOD = 60 * 60 * 4; // 4 hours

    // Status of the vault
    Status public vaultStatus;
    
    // Global config used for all SimpleBitcoinVaults
    SimpleGlobalVaultConfig public vaultConfig;

    // Vault admin addresses
    address public tunnelAdmin;
    address public operatorAdmin;

    SimpleBitcoinVaultState vaultStateChild;

    // The contract of the hBTC token
    BTCToken btcTokenContract;

    // Upon construction, this is set to the minCollateralAmount that is configured
    // by the SimpleGlobalVaultConfig. The value at construction will remain in force
    // for the lifespan of the vault, and will not change to reflect changes
    // in the SimpleGlobalVaultConfig. This is to prevent a future increase
    // in the collateral amount required to effect vaults which were created
    // before the increase went into place.
    uint256 minCollateralAmount;

    // Bitcoin custodian address
    string bitcoinCustodyAddress;

    // Whether the Bitcoin custodian address has been set
    bool bitcoinCustodyAddressSet;

    // Amount of ERC20 collateral deposited
    uint256 depositedCollateralBalance;

    // The total BTC deposits in sats this vault currently holds
    uint256 totalDepositsHeld;

    // Total pending operator BTC fees in sats
    uint256 totalPendingFeesCollected;

    // The primary UTXO txid
    bytes32 currentSweepUTXO;

    // The primary UTXO index
    uint256 currentSweepUTXOOutput;

    // The value of the primary UTXO
    uint256 currentSweepUTXOValue;

    // Amount of collateral asset (in atomic units) pending potential withdrawal by operator
    uint256 pendingCollateralWithdrawal;

    // The timestamp when the pending withdrawal of collatearl was requested.
    uint256 pendingCollateralWithdrawalRequestTime;

    // Set to true if the operator misbehaves and the vault should be fully liquidated
    bool fullLiquidationAllowed;

    // Set to true once a full liquidation has been started
    bool fullLiquidationStarted;

    // The time at which a full liquidation was started
    uint256 fullLiquidationStartTime;

    // Store the starting price of the full liquidation
    uint256 fullLiquidationStartingPrice;

    // The amount of sats that need to be repurchased that are not yet being actively liquidated
    uint256 pendingPartialLiquidationSats;

    // The counter of partial liquidations started
    uint32 partialLiquidationCounter;

    // Whether a partial liquidation is already in progress
    bool partialLiquidationInProgress;

    // Mapping of each partial liquidation index to its current state
    mapping(uint32 => PartialLiquidation) public partialLiquidationStatus;

    // When a vault wind-down procedure is initiated, this is set to the future time after which
    // the vault will enter CLOSING_INIT mode.
    uint256 public windDownTime;


    /**
    * The SimpleBitcoinVault does not require a setupAdmin, so it is not included in the
    * constructor arguments.
    */
    constructor (address _tunnelAdmin, 
                 address _operatorAdmin, 
                 BTCToken _btcTokenContract,
                 SimpleGlobalVaultConfig _vaultConfig) {
        tunnelAdmin = _tunnelAdmin;
        operatorAdmin = _operatorAdmin;
        vaultConfig = _vaultConfig;
        btcTokenContract = _btcTokenContract;
        vaultStatus = Status.CREATED;

        minCollateralAmount = vaultConfig.getMinCollateralAssetAmount();

        vaultStateChild = new SimpleBitcoinVaultState(this, _vaultConfig);
    }

    /**
    * Updates the operator admin. Only callable by the current operatorAdmin.
    *
    * @param newOperatorAdmin The new operatorAdmin to set.
    */
    function updateOperatorAdmin(address newOperatorAdmin) onlyOperatorAdmin external {
        operatorAdmin = newOperatorAdmin;
    }

    /**
    * Used by operatorAdmin to deposit collateral in the permitted ERC20 collateral token.
    * The operatorAdmin must have approved this SimpleBitcoinVault in the ERC20 contract
    * previously to allow a call to ERC20.transferFrom.
    *
    * @param amount The amount (in atomic units) of collateral to deposit
    */
    function depositCollateral(uint256 amount) public onlyOperatorAdmin returns (bool success) {
        // Make sure that a new vault cannot be initialized with less collateral than the config requires
        if (vaultStatus == Status.CREATED) {
            require(amount > vaultConfig.getMinCollateralAssetAmount(), "when depositing collateral into a new vault, the initial deposit must be at least the minimum collateral asset amount");
        }

        require(vaultStatus == Status.CREATED || vaultStatus == Status.INITIALIZING || vaultStatus == Status.LIVE,
        "can only deposit collateral to a vault that is in a created, initializing, ready, or live status");

        // Do not check for minimum collateral amount here - allow multiple indepdent deposits to add up to the minimum collateral amount if needed for going live.
        bool depositSuccessful = vaultConfig.getPermittedCollateralAssetContract().transferFrom(msg.sender, address(this), amount);

        require(depositSuccessful, "deposit to vault was not successful");

        depositedCollateralBalance += amount;

        if (vaultStatus == Status.CREATED) {
            // Created status means no assets are locked up to secure the vault, so update to INITIALIZING if in CREATED state
            vaultStatus = Status.INITIALIZING;
        }

        // If not successful, would have reverted previously
        emit CollateralDeposited(amount, depositedCollateralBalance);
        return true;
    }

    /**
    * Called by the operatorAdmin to set the BTC address that this vault will use for BTC custodianship
    * for its lifetime. Can only be set once, and is required before setting the vault to live.
    *
    * @param btcAddress The Bitcoin address which the vault will use for custodianship
    */
    function setBtcCustodianshipAddress(string memory btcAddress) external onlyOperatorAdmin {
        require(!bitcoinCustodyAddressSet, "btc custodianship address can only be set once");

        IBitcoinKit bitcoinKit = vaultConfig.getBitcoinKitContract();

        bytes memory script = bitcoinKit.getScriptForAddress(btcAddress);

        // 15 is somewhat arbitrary but smaller than all current or reasonable future address types
        require(script.length >= 15, "bitcoin address must convert to a redeem script that is at least 15 bytes");

        // Check to make sure address does not have any existing UTXOs
        UTXO[] memory utxos = bitcoinKit.getUTXOsForBitcoinAddress(btcAddress, 0, 1);
        require(utxos.length == 0, "btc custodianship address cannot have any utxos");

        bitcoinCustodyAddress = btcAddress;
        bitcoinCustodyAddressSet = true;
    }


    /**
    * Used by the operator to set the vault to LIVE. Requires that the minimum collateral deposit is met
    * and a BTC address for custodianship is set.
    */
    function goLive() external onlyOperatorAdmin {
        require(bitcoinCustodyAddressSet, "btc custodianship address must be set before going live");
        require(depositedCollateralBalance >= minCollateralAmount, "deposited collateral must be >= minimum collateral requirement");

        // Must be INITIALIZING (and not further progressed)
        require(vaultStatus == Status.INITIALIZING, "vault must be initializing before going live");

        vaultStatus = Status.LIVE;
        emit VaultLive();
    }

    /**
    * Used to determine whether the vault has gone LIVE. This is used for determining whether config
    * changes that normally require an activation window can be performed instantly because the vault
    * has not yet gone live.
    *
    * Returns "true" if the vault has *never* gone live, false otherwise (whether currently live or
    * progressed to a future closing/closed state).
    *
    * @return hasEverGoneLive Whether the vault has ever gone live
    */
    function hasGoneLive() external view returns (bool hasEverGoneLive) {
        return (vaultStatus == Status.CREATED || vaultStatus == Status.INITIALIZING);
    }

    /**
    * Checks whether a withdrawal of collateral by the vault operator is pending.
    *
    * @return isPendingWithdrawal Whether there is a pending withdrawal of collateral by the vault operator pending
    */
    function isPendingPartialCollateralWithdrawal() public view returns (bool isPendingWithdrawal) {
        return pendingCollateralWithdrawal != 0;
    }

    /**
    * When a vault has excess collateral over the set soft collateralization threshold, the
    * operator can withdraw the excess. However, users may be making deposits on Bitcoin with
    * the expectation of the vault's current excess collateral, so the withdrawal must be
    * executed in two parts:
    *   1. Initiate the collateral withdrawal with the amount of units they desire to withdraw
    *   2. After a delay, withdraw actual excess collateral up to the specified withdrawal amount
    *      if possible.
    *
    * Once a collateral withdrawal is initiated, the amount of collateral that *could* be
    * withdrawn (assuming conditions at finalization permit) is available information to
    * depositors, who can use the time until that collateral will be withdrawn to determine
    * whether their deposit will be successful.
    *
    * The delay in withdrawing collateral also ensures that any depositor who initiated
    * a deposit transaction on Bitcoin with reasonable fees to get into the Bitcoin blockchain
    * in a timely manner will not be subject to the pending potential collateral change.
    *
    * The amount that can actually be withdrawn at the end will be based on:
    *   1. The price of the asset at the time of withdrawal (decreases in the price between
    *      initiating the withdrawal and finalizing the withdrawal will cause the collateral
    *      utilization to increase, and the requested withdrawal amount may no longer be 
    *      possible to withdraw without falling below the soft collateralization threshold)
    *   2. Net changes to the BTC custodied by the vault (if there is a net increase
    *      in BTC custodied by the vault between initiating the withdrawal and finalizing
    *      the withdrawal, then the collateral utilization will also increase)
    *
    * It is possible that the price of the collateral asset increases relative to BTC *and*
    * there is a net increase in the BTC custodied by the vault, and the balance between
    * the two will determine whether the net effect is an increase or decrease in the
    * collateral utilization.
    *
    * For example, if a withdrawal is initiated when:
    *   - A vault has 100_000 units of collateral
    *   - The collateral value is 10_000 units of collateral to 1 BTC
    *   - The vault holds 2 BTC
    *   - The soft collateralization threshold is 200 (%)
    *
    * Then the amount of collateral needed to satisfy the 200% soft threshold is 40_000 units,
    * so up to 60_000 could be withdrawn, so the operator's desiredWithdrawalAmount could be
    * anything <= 60_000 units.
    *
    * But if at the time of finalization (due to net BTC inflows and/or changes in collateral value)
    * there are only 55_000 units available, then if the operator specified a quantity
    * >= 55_000, they would only be able to withdraw 55_000 during finalization.
    * 
    */
    function initiatePartialCollateralWithdrawal(uint256 desiredWithdrawalAmount) external onlyOperatorAdmin {
        // Cannot withdraw zero atomic units
        require(desiredWithdrawalAmount > 0, "withdrawal amount must not be zero");

        // Ensure there is not already a pending withdrawal
        require(!isPendingPartialCollateralWithdrawal(), "cannot initiate a partial collateral withdrawal when one is already pending");

        uint256 freeCollateral = getFreeCollateral();

        // Ensure that the desired withdrawal amount does not exceed the amount
        // of free collateral currently available in the vault.
        // This behavior could be loosened to allow larger requests that will
        // be eventually be modified based on the actual free collatearal available
        // at finalization.
        require(desiredWithdrawalAmount <= freeCollateral, "desired withdrawal amount must be less than free collateral");

        pendingCollateralWithdrawal = desiredWithdrawalAmount;
        pendingCollateralWithdrawalRequestTime = block.timestamp;
    }

    /**
    * Finalizes a partial collateral withdrawal, returning collateral to the operator admin.
    *
    * Allows withdrawal of the lower of:
    *   - The *current* available collateral under the soft collateralization threshold, OR
    *   - The originally requested withdrawal amount
    */
    function finalizePartialCollateralWithdrawal() external onlyOperatorAdmin {
        // Cannot perform a partial collateral withdrawal unless one has already been initiated
        require(isPendingPartialCollateralWithdrawal(), "there is no pending collateral withdrawal to finalize");

        // Cannot perform a partial collateral withdrawal if a partial liquidation is in progress or could be triggered
        require(!partialLiquidationInProgress && (pendingPartialLiquidationSats > 0), "there is a partial liquidation authorized or in progress");

        // Cannot perform a partial collateral withdrawal if a full liquidation is active.
        // fullLiquidationAllowed should never be false if fullLiquidationStarted is true, but check both as extra sanity check. 
        require(!fullLiquidationAllowed && !fullLiquidationStarted, "there is a full liquidation authorized or in progress");

        // Ensure that sufficient time has elapsed from when the partial collateral withdrawal was requested
        require(pendingCollateralWithdrawalRequestTime + PARTIAL_COLLATERAL_WITHDRAWAL_DELAY <= block.timestamp, "the waiting period for a partial collateral withdrawal has not elapsed");

        // Only allow operator to withdraw free collateral OR the requested withdrawal amount, whichever is lower
        uint256 withdrawalAmount = getFreeCollateral();
        if (pendingCollateralWithdrawal < withdrawalAmount) {
            withdrawalAmount = pendingCollateralWithdrawal;
        }

        // Transfter the collateral to the operator admin (same as msg.sender)
        bool withdrawalSuccess = vaultConfig.getPermittedCollateralAssetContract().transfer(operatorAdmin, withdrawalAmount);
        require(withdrawalSuccess, "unable to transfer the specified amount of collateral");

        // Deduct withdrawal amount from deposited collateral balance
        depositedCollateralBalance = depositedCollateralBalance - withdrawalAmount;
    }

    /**
    * Calculates how much collateral (in atomic units) is available which is over the current
    * softCollateralizationThreshold based on the current price reported by the price oracle.
    *
    * For example, if:
    *   - 100_000_000 units of an ERC20 are deposited as collateral
    *   - The price oracle reports that 10_000_000 units of that ERC20 = 1 BTC
    *   - The softCollateralizationThreshold is 130 (%)
    *   - The vault currently holds 5 BTC
    *
    * Then:
    *   - The vault must keep 5 * 10_000_000 * 130 / 100 = 65_000_000 units of collateral
    *     (note that this is 6.5 BTC worth of collateral, and 6.5/5 = 1.3 which corresponds
    *     to the softCollateralizationThreshold of 130 (%)).
    *   - Meaning 100_000_000 - 65_000_000 = 35_000_000 units of collateral are free
    *
    * This function takes into account any pending withdrawals of collateral;
    * if an operator has initiated a pending collateral withdrawal then this function
    * will subtract the maximum potential pending withdrawal.
    *
    * @return freeCollateralAtomicUnits The amount of free collateral in atomic units
    */

    function getFreeCollateral() public view returns (uint256 freeCollateralAtomicUnits) {
        uint256 utilizedCollateral = getUtilizedCollateral();
        uint256 conservativeTotalCollateral = depositedCollateralBalance - pendingCollateralWithdrawal;

        if (utilizedCollateral > conservativeTotalCollateral) {
            // This can happen on an edge case where the pendingCollateralWithdrawal
            // would decrease the total collateral below what is requied to be kept.
            // This pending withdrawal wound not be permitted to happen in its entirety,
            // so the actual withdrawal will either be trimmed down to what is
            // permitted or disallowed entirely. Either way, there is no free collateral.
            return 0;
        }

        return conservativeTotalCollateral - utilizedCollateral;
    }

    /**
    * Calculate how much of the current collateral is utilized to maintain the
    * current active softCollateralizationThreshold.
    *
    * For example, if:
    *   - 100_000_000 units of an ERC20 are deposited as collateral
    *   - The price oracle reports that 10_000_000 units of that ERC20 = 1 BTC
    *   - The softCollateralizationThreshold is 130 (%)
    *   - The vault currently holds 5 BTC
    *
    * Then:
    *   - The vault must keep 5 * 10_000_000 * 130 / 100 = 65_000_000 units of collateral
    *     (note that this is 6.5 BTC worth of collateral, and 6.5/5 = 1.3 which corresponds
    *     to the softCollateralizationThreshold of 130 (%)).
    */
    function getUtilizedCollateral() public view returns (uint256 utilizedCollateralAtomicUnits) {
        IAssetPriceOracle oracle = vaultConfig.getPriceOracle();
        // deposits held (in sats) times quantity of collateral in atomic units for 1 BTC
        // times the soft collateralization threshold, divided by 100 since the collateralization
        // threshold is a percentage (ex: 130 = 130%), divided by 100_000_000 to cancel out
        // the price being denominated in Bitcoin.
        uint256 utilizedCollateral = totalDepositsHeld * oracle.getAssetQuantityToBTC() * vaultStateChild.softCollateralizationThreshold() / 100 / 100_000_000;

        // If this happens, it means the vault is undercollateralized, and a liquidation
        // might not ensure vault solvency.
        //
        // The incentives for liquidation should prevent this from happening except in
        // the most extreme cases of rapid negative price movement of the collateral value 
        // relative to BTC.
        //
        // If this does occur, no action is taken in this function, but since only the
        // total deposited collateral balance could be "utilized", return that value instead.
        if (utilizedCollateral > depositedCollateralBalance) {
            return depositedCollateralBalance;
        }

        return utilizedCollateral;
    }


    /**
    * Returns the current status of the vault.
    *
    * @return status The status of the vault
    */
    function getStatus() external view returns (Status status) {
        return vaultStatus;
    }


    /**
    * The SimpleBitcoinVault does not require a deposit preconfirmation step.
    *
    * @return requiresPreconfirmation False indicating the SimpleBitcoinVault does not require a deposit preconfirmation step
    */
    function requiresDepositPreconfirmation() external pure returns (bool requiresPreconfirmation) {
        return false;
    }


    /**
    * The SimpleBitcoinVault does not use preconfirmations, but implements as an immediate revert
    * to satisfy the IBitcoinVault interface.
    */
    function preconfirmDeposit(bytes32 txid, uint256 outputIndex, bytes memory extraInfo) external pure returns (bool success) {
        revert("preconfirmations not used for SimpleBitcoinVault");
    }

    /**
    * Begins the vault wind-down procedure, which will set the vault to CLOSING_INIT
    * state after the wind-down delay. After the vault is set to CLOSING_INIT, 
    * no new deposits can be confirmed.
    */
    function windDownVault() external onlyOperatorAdmin {
        // When called externally, use current timestamp plus the wind down grace period
        windDownVaultImpl(block.timestamp + WIND_DOWN_DEPOSIT_GRACE_PERIOD);
    }

    /**
    * Implementation for winding down vault, separated out to allow the operator admin
    * to trigger any time, or internal functions to call this directly and bypass
    * the operator check.
    */
    function windDownVaultImpl(uint256 _windDownTime) private {
        require(windDownTime == 0, "vault is already winding down");
        windDownTime = windDownTime;
    }

    /**
    * Returns whether the vault is currently winding down.
    * Returns true if vault is in the process of winding down or has already been wound down.
    *
    * @return windingDown Whether this vault is winding down.
    */
    function isWindingDown() public view returns (bool windingDown) {
        // If the global config indicates that this vault is deprecated, then it is
        // winding down even if the actual wind-down procedure has not been started
        // on this particular vault yet.
        if (vaultConfig.isVaultSystemDeprecated()) {
            return true;
        }

        // Otherwise, check whether a wind down time has been set
        return (windDownTime != 0);
    }

    /**
    * Finalizes a wind down after the wind down waiting period has elapsed by setting
    * the vault to Status.CLOSING_INIT.
    * Callable by anyone.
    */
    function finalizeWindDown() external {
        require(block.timestamp >= windDownTime, "wind down time has not yet occurred");
        require(vaultStatus == Status.LIVE, "can only wind down a vault that is currently live");
        vaultStatus = Status.CLOSING_INIT;
    }

    /**
    * Finalizes a vault to CLOSED when there is no more BTC custodied by the vault.
    * Returns any remaining ERC20 collateral to the vault operator.
    * Note that the operator could (and generally will) have pending fees that they
    * have not minted yet. If the tunnel system mnited those as hBTC then the vault
    * could not be closed as it would still be custodying BTC on behalf of the system
    * (backing the hBTC that the operator minted), so instead just zero out the 
    * pending fees, and the operator own them on BTC directly.
    */
    function closeVault() external onlyOperatorAdmin {
        require(vaultStatus == Status.CLOSING_VERIF, "can only close a vault that is in CLOSING_VERIF state");
        require(totalDepositsHeld == 0, "can not close a vault until it has no deposits held");
        vaultStatus = Status.CLOSED;
        vaultConfig.getPermittedCollateralAssetContract().transfer(operatorAdmin, depositedCollateralBalance);
        totalPendingFeesCollected = 0;
    }

    /** 
    * Process an incoming deposit, returning whether the deposit was successful,
    * the number of sats to credit, and the recipient to credit them to.
    * This function should only be called by the BitcoinTunnelManager, who will
    * mint the corresponding BTC tokens in response to the deposit being confirmed.
    *
    * Can only be called by the tunnel admin (the BitcoinTunnelManager who has the
    * authority to mint hBTC based on what this vault returns).
    *
    * @param txid The transaction ID of the deposit transaction on Bitcoin
    * @param outputIndex The index of the output in the transaction which constitutes the deposit
    * @param extraInfo Arbitrary bytes that can contain additional data necessary to confirm a deposit
    *
    * @return success Whether the deposit was successful (the depositor should be credited)
    * @return totalDeposit The amount of sats that were deposited to the vault *before* fees are charged
    * @return netDeposit The net amount of hBTC to credit the depositor with, is netDeposit minus charged fees
    * @return depositor The EVM address that should be credited for the deposit
    */
    function confirmDeposit(bytes32 txid, uint256 outputIndex, bytes memory extraInfo) external onlyTunnelAdmin returns (bool success, uint256 totalDeposit, uint256 netDeposit, address depositor) {
        if (fullLiquidationStarted) {
            require(fullLiquidationStartTime + FULL_LIQUIDATION_DEPOSIT_GRACE_PERIOD >= block.timestamp, "vault has been in liquidation for more than 4 hours");
        }

        require(vaultStatus == Status.LIVE, "can only process a deposit on a live vault");

        // Check if the global config indicates that this vault should be deprecated, and if so start the wind down
        if (vaultConfig.isVaultSystemDeprecated() && windDownTime == 0) {
            windDownVaultImpl(vaultConfig.vaultSystemDeprecationTime() + WIND_DOWN_DEPOSIT_GRACE_PERIOD);
        }

        if (isWindingDown() && block.timestamp >= windDownTime) {
            // Special case if we're past the windDownTime but the vault has not been set to CLOSING_INIT yet.
            // Set to CLOSING_INIT and return a failed deposit.
            vaultStatus = Status.CLOSING_INIT;
            return (false, 0, 0, address(0));
        }

        // The SimpleBitcoinVault only permits one deposit per TxID regardless of whether multiple outputs
        // were to the Vault's custodianship address.
        require (!vaultStateChild.isDepositAcknowledged(txid), "txid has already been confirmed");
        require (outputIndex <= 8, "output index must be one of the first 8 outputs");

        IBitcoinKit bitcoinKit = vaultConfig.getBitcoinKitContract();

        // The depositer must format the deposit Bitcoin tranaction to contain the
        // Bitcoin output corresponding to this vault and the OP_RETURN with their
        // EVM address to credit for the deposit within the number of outputs
        // returned by the BitcoinKit's built-in getTransactionByTxId.
        Transaction memory btcTx = bitcoinKit.getTransactionByTxId(txid);

        require(outputIndex < btcTx.outputs.length, "claimed outputindex is greater than the number of outputs accessible in transaction");

        depositor = address(0);

        uint256 outputMaxLen = btcTx.outputs.length;
        if (outputMaxLen > 8) {
            outputMaxLen = 8;
        }

        for (uint32 idx = 0; idx < outputMaxLen; idx++) {
            Output memory output = btcTx.outputs[idx];

            // The EVM address to credit for the deposit must be in an OP_RETURN.
            // Permitted formats are:
            //   1. The 20 bytes of the address (22 byte output total)
            //   2. 40 bytes representing a 20-byte address in ASCII (hex) (42 byte output total)
            if (output.script.length >= 22 && output.script[0] == 0x6a) {
                if (output.script.length == 22) {
                    // OP_RETURN OP_PUSHBYTES_40 <20 byte address>
                    depositor = bytesToAddressOffset(output.script, 2);
                    break;
                } else if (output.script.length == 42) {
                    bytes memory extractedAddress = hexAsciiBytesToBytes(output.script, 2, 42);
                    depositor = bytesToAddress(extractedAddress);
                    break;
                }
            }
        }

        // Ensure an EVM address to credit was properly extracted from OP_RETURN
        require(depositor != address(0), "could not extract an EVM address to credit from deposit");

        // Convert BTC custodianship address to the script and ensure the claimed deposit output actually locked funds to this script
        bytes memory vaultHoldingPenScript = bitcoinKit.getScriptForAddress(bitcoinCustodyAddress);
        Output memory claimedDepositOutput = btcTx.outputs[outputIndex];
        require(claimedDepositOutput.script.length == vaultHoldingPenScript.length, "claimed deposit output length must match holding pen address deposit script length");
        require(keccak256(claimedDepositOutput.script) == keccak256(vaultHoldingPenScript), "claimed deposit output script must match vault holding pen script");

        // Check amount of sats deposited
        uint256 satsDepositedFromOutput = claimedDepositOutput.outValue;
        require(satsDepositedFromOutput >= MINIMUM_DEPOSIT_SATS, "deposit must meet the minimum deposit size threshold");

        uint256 depositFeeSats = vaultStateChild.calculateDepositFee(satsDepositedFromOutput);
        netDeposit = satsDepositedFromOutput - depositFeeSats;

        // Total deposits held on behalf of the protocol is increased by the amount after fees, but operator
        // does not get their portion of fees until they sweep (if required - see special case where no sweep UTXO exists)
        totalDepositsHeld = totalDepositsHeld + netDeposit;

        // If this is the first deposit or a previous withdrawal completely consumed sweep,
        // consider this deposit the main UTXO rather than requiring a sweep
        if (currentSweepUTXO == bytes32(0)) {
            currentSweepUTXO = txid;
            currentSweepUTXOOutput = outputIndex;
            currentSweepUTXOValue = claimedDepositOutput.outValue;

            // Since no sweep is required, operator gets the entire fee amount immediately
            creditOperatorWithFees(depositFeeSats);
            depositFeeSats = 0;
        }

        // Record that the deposit has been acknowledged
        vaultStateChild.acknowledgeDeposit(txid, outputIndex, depositFeeSats);

        return (true, satsDepositedFromOutput, netDeposit, depositor);
    }
    /**
    * Used whenever an operator performs an action (sweep or withdrawal finalization) which credits
    * fees to the operator. 
    *
    * If the operator is currently running a deficit that could lead to a partial liquidation
    * that has not yet been triggered, this credit function will decrease the deficit before
    * crediting the operator's pending fees.
    *
    * While a partial liquidation opportunity will likely be taken quickly by arbitrage seekers
    * (and that is the intended design, to always prioritize vault solvency), small deficits may
    * occur which are not worth arbitragers liquidating, and this mechanic provides a simple way
    * for regular vault operation to wipe out these dust liquidations in a way that also favors
    * operators.
    *
    * @param fees The fees to be credited to the operator
    */
    function creditOperatorWithFees(uint256 fees) private {
        if (pendingPartialLiquidationSats > 0) {
            if (pendingPartialLiquidationSats > fees) {
                pendingPartialLiquidationSats = pendingPartialLiquidationSats - fees;
                return;
            } else {
                fees = fees - pendingPartialLiquidationSats;
                pendingPartialLiquidationSats = 0;
            }
        }
        totalPendingFeesCollected = totalPendingFeesCollected + fees;
    }

    /**
    * The SimpleBitcoinVault permits its operators to mint collected fees as hBTC. 
    * 
    * Security Note:
    * Implementations should only allow the tunnelAdmin (generally a BitcoinTunnelManager) 
    * to call this function, as it is the contract responsible for minting the corresponding
    * hBTC.
    * 
    * @param operator The address of the operator to process a collected fee mintage for (passed through)
    * @param amountToMint The amount of collected fees to mint
    */
    function mintOperatorFees(address operator, uint256 amountToMint) external onlyTunnelAdmin returns (bool success, uint256 sats) {
        require(operator == tunnelAdmin, "operator fees can only be minted by tunnel admin");
        require(totalPendingFeesCollected > 0, "there must be a non-zero number of pending fees to mint operator fees");
        require(amountToMint >= totalPendingFeesCollected, "cannot mint more operator fees than have been collected");
        totalPendingFeesCollected = totalPendingFeesCollected - amountToMint;
        return (true, amountToMint);
    }


    /**
    * Initiates a withdrawal from the vault which must be sent to the specified destinationScript.
    * The SimpleBitcoinVault will calculate the fee charged on the withdrawal based on either
    * the minimum withdrawal fee or the bps withdrawal fee, whichever is higher.
    *
    * The amount of the withdrawal minus the withdrawal fee (as calculated based on the settings
    * of the vault operator) is the exact amount in satoshis that will actually be paid to the
    * specified destination script.
    *
    * Security Note:
    * Implementations should only allow the tunnelAdmin (generally a BitcoinTunnelManager)
    * to call this function, as it is the contract responsible for burning hBTC corresponding
    * to the withdrawal.
    *
    * @param destinationScript The unlocking script that the withdrawn BTC must be sent to
    * @param amountSats The number of sats withdrawn (BTC representative token burnt) by the withdrawer
    *        (the amount actually paid to the specified destination script will be this value
    *        minus the calculated fees).
    * @param originator The originator EVM address of the withdrawal
    *
    * @return success Whether the withdrawal *initialization* was successful
    * @return feeSats The fee charged in sats on the withdrawal
    * @return uuid A unique UUID that will be used to manage the withdrawal through its lifecycle.
    */
    function initiateWithdrawal(bytes memory destinationScript, uint256 amountSats, address originator) external onlyTunnelAdmin returns (bool success, uint256 feeSats, uint32 uuid) {
        require(amountSats <= getNetDeposits(), "vault cannot process a withdrawal for more than its net deposits");
        require(amountSats >= MINIMUM_WITHDRAWAL_SATS, "vault cannot process a withdrawal lower than its minimum withdrawal");
        require(destinationScript.length >= MIN_VALID_BTC_SCRIPT_SIZE, "withdrawal destination script must be at least the minimum permitted script size");
        require(destinationScript.length <= MAX_VALID_BTC_SCRIPT_SIZE, "withdrawal destination script must be no larger than the maximum permitted script size");
        require(vaultStatus == Status.LIVE || vaultStatus == Status.CLOSING_INIT, "can only process a withdrawal on a live or closing_init vault");
        require(!fullLiquidationStarted, "vault is being fully liquidated and cannot accept withdrawals.");

        require(vaultStateChild.pendingWithdrawalAmountSat() + amountSats <= totalDepositsHeld, "cannot withdraw more sats than is held by vault");

        uint256 withdrawalFeeSats = vaultStateChild.calculateWithdrawalFee(amountSats);

        uint256 pendingWithdrawalAmountSat = 0;

        (uuid, pendingWithdrawalAmountSat) = vaultStateChild.internalInitializeWithdrawal(amountSats, withdrawalFeeSats, block.timestamp, destinationScript, originator);

        if (vaultStatus == Status.CLOSING_INIT) {
            // If the vault is in closing mode and the pending withdrawal amount is equal to the BTC custodied,
            // change the vault to CLOSING_VERIF
            if (pendingWithdrawalAmountSat == totalDepositsHeld) {
                vaultStatus = Status.CLOSING_VERIF;
            }
        }

        return (true, withdrawalFeeSats, uuid);
    }

    /**
    * Finalizes a withdrawal by proving to the vault that the withdrawal was processed properly.
    * All sweeps and withdrawals must be processed in the order they occurred on Bitcoin. It is possible
    * to call this function with a valid withdrawal txid that can't be confirmed because the vault's knowledge
    * about the correct main sweep UTXO at the time of the withdrawal being processed is not correct.
    *
    * Withdrawal transactions must be as follows:
    *   - Only spends the main UTXO (no other inputs)
    *   - First output is the withdrawal
    *   - Second output is back to the vault (unless withdrawal spends UTXO entirely)
    *   - No other outputs exist
    *
    * @param txid The TxID of the Bitcoin transaction which is claimed by the operator to fulfill the withdrawal
    * @param withdrawalIndex The index of the withdrawal the operator claims this TxID fulfills
    *
    * @return success Whether or not the withdrawal was finalized correctly
    */
    function finalizeWithdrawal(bytes32 txid, uint32 withdrawalIndex) external onlyOperatorAdmin returns (bool success) {
        require(vaultStateChild.isWithdrawalFulfilled(withdrawalIndex), "withdrawal must not already be mapped to a fulfilling txid");

        IBitcoinKit bitcoinKit = vaultConfig.getBitcoinKitContract();

        // Get the actual withdrawal transaction from Bitcoin based on the txid
        Transaction memory btcTx = bitcoinKit.getTransactionByTxId(txid);

        require(btcTx.inputs.length == 1, "withdrawal transaction must only have one input");
        require(btcTx.inputs[0].inputTxId == currentSweepUTXO && btcTx.inputs[0].sourceIndex == currentSweepUTXOOutput,
        "withdrawal transaction must consume the current sweep utxo");
        require(btcTx.outputs.length >= 1, "withdrawal transaction must have at least one output");

        uint256 inValue = btcTx.inputs[0].inValue;

        Withdrawal memory withdrawal = vaultStateChild.getWithdrawal(withdrawalIndex);

        Output memory withdrawalOutput = btcTx.outputs[0];
        require(keccak256(withdrawalOutput.script) == keccak256(withdrawal.destinationScript), 
        "script of first output of withdrawal tx must match script of requested withdrawal");

        uint256 withdrawalExpectedNet = withdrawal.amount - withdrawal.fee;
        require(withdrawalExpectedNet == withdrawalOutput.outValue, "amount of first withdrawal tx output must exactly match expected net after fees");

        uint256 outValue = withdrawalOutput.outValue;

        if (btcTx.outputs.length > 1) {
            require(btcTx.outputs.length == 2, "withdrawal tx can only have a maximum of two outputs");
            outValue = outValue + btcTx.outputs[1].outValue;

            uint256 btcFeesPaid = inValue - outValue;

            // Operator gets net of collected fees minus the fees actually paid on BTC
            uint256 feesCollected = 0;
            uint256 feesOverpaid = 0;
            if (withdrawal.fee > btcFeesPaid) {
                feesCollected = withdrawal.fee - btcFeesPaid;
            } else {
                feesOverpaid = btcFeesPaid - withdrawal.fee;
            }

            // If more btc fees were paid than were collected, first try to deduct excess fees from the operator's
            // uncollected pending fees
            if (feesOverpaid > 0) {
                if (feesOverpaid <= totalPendingFeesCollected) {
                    totalPendingFeesCollected = totalPendingFeesCollected - feesOverpaid;
                    feesOverpaid = 0;
                } else {
                    uint256 temp = totalPendingFeesCollected;
                    totalPendingFeesCollected = 0;

                    // Credit remainder as a pending partial liquidation
                    pendingPartialLiquidationSats = pendingPartialLiquidationSats + feesOverpaid - temp;
                }
            } else {
                // feesOverpaid = 0 meaning feesCollected is >= 0
                creditOperatorWithFees(feesCollected);
            }

            // If the fees overpaid are still greater than zero after attempting to fix with operator's unclaimed
            // balance, then add the missing fees to the pending partial liquidation.
            pendingPartialLiquidationSats = pendingPartialLiquidationSats + feesOverpaid;

            // Set the new sweep UTXO
            currentSweepUTXO = txid;
            currentSweepUTXOOutput = 1;
            currentSweepUTXOValue = btcTx.outputs[1].outValue;

            // Save the withdrawal TxId
            vaultStateChild.saveWithdrawalFulfillment(withdrawalIndex, txid, withdrawal.amount);

            totalDepositsHeld = totalDepositsHeld - withdrawal.amount;
            return true;
        } else {
            // There is only one output, which is only allowed if the output completely clears out all BTC held by
            // the vault based on confirmed deposits. This is a rare edge case because it also means that the operator
            // decided to pay exactly the collected fees as the BTC fees so is unlikely to happen in practice.
            // If this occurs, then set the current sweep UTXO to nothing, and the next deposit will set a new sweep
            // as the deposit itself similar to the first deposit to a vault.

            uint256 btcFeesPaid = inValue - outValue;
            if (btcFeesPaid > withdrawal.fee) {
                // Operator paid more in fees than were anticipated by the withdrawal fee charged - this should only
                // happen when the extra amount comes out of fees the operator has already collected and chose to give
                // up, but could also happen if the operator accidentally didn't include an output to use as the
                // new sweep, necessitating a partial liquidation.
                uint256 feesOverpaid = btcFeesPaid - withdrawal.fee;
                if (feesOverpaid <= totalPendingFeesCollected) {
                    totalPendingFeesCollected = totalPendingFeesCollected - feesOverpaid;
                    feesOverpaid = 0;
                } else {
                    uint256 temp = totalPendingFeesCollected;
                    totalPendingFeesCollected = 0;
                    feesOverpaid = feesOverpaid - temp;
                }

                // If the fees overpaid are still greater than zero after attempting to fix with operator's unclaimed
                // balance, then add the missing fees to the pending partial liquidation.
                pendingPartialLiquidationSats = pendingPartialLiquidationSats + feesOverpaid;
            } // else: do nothing, as no fees could possibly be collected if there is only one output

            // The entire sweep UTXO was spent, so there is now no sweep.
            // The sweep UTXO will get set to the next deposit confirmed.
            currentSweepUTXO = bytes32(0);
            currentSweepUTXOOutput = 0; // Doesn't matter, currentSweepUTXO is checked against bytes32(0) to guard
            currentSweepUTXOValue = 0;

            vaultStateChild.saveWithdrawalFulfillment(withdrawalIndex, txid, withdrawal.amount);

            totalDepositsHeld = totalDepositsHeld - withdrawal.amount;

            return true;
        }
    }

    /**
    * Under normal operation, the first confirmed deposit is automatically set as the sweep UTXO.
    * When additional deposits occur, they are swept together with the original sweep UTXO to create new sweep UTXOs.
    * Withdrawals spend the sweep UTXO and create a new sweep UTXO.
    *
    * In the rare event that an operator consumes the full sweep UTXO to process a withdrawal,
    * the next deposit to be confirmed would automatically be set as the sweep UTXO.
    *
    * However, an edge case can occur because anyone can call the confirmDeposit function via the
    * BitcoinTunnelManager, meaning an operator could process a withdrawal on BTC that spends the
    * entire sweep UTXO, and then a user could confirm a deposit before the operator finalizes the
    * withdrawal on Hemi. As a result, the deposit confirmation would not set the sweep UTXO to
    * the deposit because the vault believes the sweep UTXO is unspent, but upon finalizing the
    * withdrawal the vault would have no UTXO, and calling the normal processSweep function would
    * not work because it assumes the existence of a sweep UTXO as the first input.
    *
    * Rather than handle this edge-case in the processSweep function which would introduce
    * unnecessary complexity/gas costs in the standard case, operators can call this function
    * to set one of the confirmed but unswept deposits as the sweep UTXO.
    *
    * Additionally, when the sweep UTXO only contains a dust amount which is lower than the BTC
    * fees required to consume it as an input in a sweep transaction, the operator can use this
    * function with abandonExistingUTXO=true to abandon the current sweep UTXO (subtracting the
    * abandoned UTXO's value from the operator's collected fees and allowing a partial liquidation
    * to recover additional fees if required). While abandoning a UTXO costs the operator, in some
    * cases it may be cheaper to abandon the UTXO than pay the fees required to spend it which also
    * comes out of the operator's revenue.
    *
    * If there is a sweep UTXO set, it cannot be abandoned unless there is a valid unswept confirmed
    * deposit UTXO to use.
    *
    * @param depositTxId The transaction ID of the unswept confirmed deposit to count as the sweep UTXO
    * @param abandonExistingUTXO Whether to forcibly abandon an existing sweep UTXO and chare the operator for the abandoned value.
    */
    function assignConfirmedDepositAsSweep(bytes32 depositTxId, bool abandonExistingUTXO) external onlyOperatorAdmin {
        uint256 depositFee = vaultStateChild.getCollectableFees(depositTxId);

        // depositFee is only non-zero for a txid after a deposit is confirmed and before it is swept
        require(depositFee > 0, "deposit txid either not confirmed or already swept");

        if (currentSweepUTXO != bytes32(0)) {
            // There is already a sweep UTXO set, so only replace it if abandoning is allowed.
            require(abandonExistingUTXO, "cannot assign a confirmed deposit as sweep UTXO when one already exists and abandoning is not permitted");
            uint256 abandonedUTXOValue = currentSweepUTXOValue;
            if (abandonedUTXOValue <= totalPendingFeesCollected) {
                totalPendingFeesCollected = totalPendingFeesCollected - abandonedUTXOValue;
            } else {
                // Subtract as much as possible from the pending operator fees, then satisfy the remainder with a partial liquidation
                uint256 temp = totalPendingFeesCollected;
                totalPendingFeesCollected = 0;
                pendingPartialLiquidationSats = pendingPartialLiquidationSats + abandonedUTXOValue - temp;
            }
        }

        IBitcoinKit bitcoinKit = vaultConfig.getBitcoinKitContract();

        // Get the actual deposit transaction from Bitcoin based on the txid so we can recover output value
        Transaction memory btcTx = bitcoinKit.getTransactionByTxId(depositTxId);

        // Do not have to check if outputIndex is within transaction bounds as this check was already
        // performed on deposit confirmation.
        currentSweepUTXO = depositTxId;
        currentSweepUTXOOutput = vaultStateChild.getDepositOutputIndex(depositTxId);
        currentSweepUTXOValue = btcTx.outputs[currentSweepUTXOOutput].outValue;

        // Credit operator with the full fees of the confirmed deposit as no sweep fee is required
        creditOperatorWithFees(depositFee);

        // Same as a regular sweep, set the fees to zero to indicate they have been collected
        vaultStateChild.saveFeesCollected(depositTxId);
    }

    /**
    * Processes a sweep transaction, which must consume the current sweep UTXO as the first input,
    * and can spend up to seven additional un-sweeped deposits as additional inputs to create a single
    * output which becomes the new sweep UTXO.
    *
    * There is a possible edge case where a vault holding unswept confirmed deposits can have no
    * active sweep UTXO. If that occurs, the operator should call the assignConfirmedDepositAsSweep()
    * function first, and then process a sweep of other confirmed but unswept deposits with this
    * function if needed.
    *
    * @param sweepTxId The transaction ID of the sweep transaction to process
    */
    function processSweep(bytes32 sweepTxId) external onlyOperatorAdmin {
        require(sweepTxId != bytes32(0), "sweep txid cannot be zero");

        IBitcoinKit bitcoinKit = vaultConfig.getBitcoinKitContract();

        // Get the actual withdrawal transaction from Bitcoin based on the txid
        Transaction memory btcTx = bitcoinKit.getTransactionByTxId(sweepTxId);

        require(btcTx.inputs.length >= 2 && btcTx.inputs.length <= 8, "a sweep transaction must have at least two inputs and no more than 8");
        require(btcTx.outputs.length == 1, "a sweep transaction must have a single output");

        Input memory oldSweep = btcTx.inputs[0];
        require(oldSweep.inputTxId == currentSweepUTXO && oldSweep.sourceIndex == currentSweepUTXOOutput, "first input of sweep must consume old sweep txid");

        uint256 oldSweepValue = btcTx.inputs[0].inValue;
        
        // The value of all swept deposits minus their respective charged fees
        uint256 netDepositValue = 0;

        // Total fees collected, before we remove BTC fee paid for sweep
        uint256 totalFees = 0;
        // Loop through all remaining inputs, checking that they are each a confirmed deposit
        for (uint32 idx = 1; idx < btcTx.inputs.length; idx++) {
            Input memory depositIn = btcTx.inputs[idx];

            uint256 depositFee = vaultStateChild.getCollectableFees(depositIn.inputTxId);

            // Deposit either not yet acknowledged or already swept. If already swept, the depositFee
            // is set to 0.
            require(depositFee > 0, "deposit fee must be greater than zero, either not acknowledged or already swept");

            // Make sure that the input index is the same as the output index of the deposit transaction that was confirmed
            require(vaultStateChild.getDepositOutputIndex(depositIn.inputTxId) == depositIn.sourceIndex, "sweep must spend the input using an input index that matches the output index of the confirmed deposit");

            uint256 inValue = depositIn.inValue;
            uint256 net = inValue - depositFee;
            netDepositValue = netDepositValue + net;
            totalFees = totalFees + depositFee;

            // Mark the deposit as swept by setting the fees to zero
            vaultStateChild.saveFeesCollected(depositIn.inputTxId);
        }

        Output memory newSweep = btcTx.outputs[0];

        // Calculate the net amount swept as the value of the output minus the original sweep value
        uint256 sweptValue = newSweep.outValue - oldSweepValue;

        // If the sweptValue is less than the netDepositValue, then the operator had to spend more BTC fees than
        // they charged users for, so try to take it out of the operator's collected fees. If there are not enough
        // collected fees to cover, then start a partial liquidation.
        if (sweptValue < netDepositValue) {
            uint256 diff = netDepositValue - sweptValue;
            if (diff <= totalPendingFeesCollected) {
                totalPendingFeesCollected = totalPendingFeesCollected - diff;
            } else {
                diff = diff - totalPendingFeesCollected;
                totalPendingFeesCollected = 0;

                // Reamining diff needs to be liquidated
                pendingPartialLiquidationSats = pendingPartialLiquidationSats + diff;
            }
        }

        currentSweepUTXO = sweepTxId;
        currentSweepUTXOOutput = 0; // Always zero as sweep tx only has one output which is the sweep output
        currentSweepUTXOValue = newSweep.outValue;
    }

    /**
    * Begins a partial liquidation based on the current value of pendingPartialLiquidationSats.
    *
    * To begin a partial liquidation, the caller triggering the partial liquidation must submit a starting
    * bid, which is the amount of collateral they request in return for the required amount of hBTC.
    *
    * Caller passes in the bid along with the amount of hBTC they are expecting to pay, which is provided
    * as a sanity check to make sure the caller's bid is only submitted and a liquidation is kicked off
    * when the amount of hBTC they are bidding with is what they expect.
    *
    * Caller also passes in a timestamp before which the bid must be processed to be accepted, so that
    * a signed partial liquidation initiation transaction can't be replayed later.
    *
    * The vault transfers the hBTC to itself, and will only return it to the sender if someone else
    * outbids them OR a full vault liquidation is triggered and the partial liquidation is rolled into
    * the full liquidation.
    * 
    * If pendingPartialLiquidationSats > 0, then previous withdrawal finalizations or sweep confirmations
    * have increased this value based on the amount of BTC fees overpaid for on-BTC actions that the operator
    * must make the vault whole for.
    *
    * When a partial liqudation is started, 2x the amount of collateral that is equivalent to
    * the value of the hBTC to be recovered is reserved and an auction for the partial liquidation begins.
    *
    * If the operator misbehaves in a way that allows a full liquidation to be performed, the pending
    * partial liquidation is halted and all pending liquidations are rolled into the full liquidation.
    *
    * @param startingBid The amount of collateral asset the bidder wants to receive for their hBTC
    * @param hBTCQuantity The amount of hBTC the bidder will purchase (must match the amount to be liquidated)
    * @param maxAcceptanceTimestamp The timestamp after which this bid is invalid
    * 
    */
    function beginPartialLiquidation(uint256 startingBid, uint256 hBTCQuantity, uint256 maxAcceptanceTimestamp) external {
        require(!partialLiquidationInProgress, "there is already a partial liquidation in progress");
        require(pendingPartialLiquidationSats > 0, "there must be a nonzero pending liquidation amount");
        require(pendingPartialLiquidationSats == hBTCQuantity, "the provided hBTC quantity is not the amount of sats to be liquidated");
        require(block.timestamp <= maxAcceptanceTimestamp, "this bid is no longer valid based on the max acceptance timestamp");
        require(!fullLiquidationAllowed, "a full liquidation is permitted");

        if (partialLiquidationCounter > 0) {
            // A partial liquidation has been conducted previously, ensure that it has finished
            PartialLiquidation memory previousLiquidation = partialLiquidationStatus[partialLiquidationCounter - 1];
            require (previousLiquidation.finished, "a partial liquidation is already in progress");
        }

        // Transfer the spedified amount of hBTC to this contract to submit a bona-fide bid
        bool transferResult = btcTokenContract.transferFrom(msg.sender, address(this), hBTCQuantity);
        require(transferResult, "specified hBTC could not be collected");

        PartialLiquidation memory pl = PartialLiquidation(pendingPartialLiquidationSats, block.timestamp, startingBid, block.timestamp, msg.sender, false);
        partialLiquidationStatus[partialLiquidationCounter] = pl;

        // Increment counter
        partialLiquidationCounter++;

        // Set pending liquidation sats to 0 as it has been cleared out with this pending partial liquidation
        pendingPartialLiquidationSats = 0;

        // A partial liquidation is now in progress
        partialLiquidationInProgress = true;
    }

    /**
    * When a partial collateal liquication is already in progress, outbid the current best bidder for the
    * amount of hBTC being liquidated.
    *
    * @param newBid The amount of collateral asset the bidder wants to receive for their hBTC
    * @param hBTCQuantity The  amount of hBTC the bidder will purchase (must match the amount to be liquidated)
    * @param maxAcceptanceTimestamp The timestamp after which this bid is invalid
    */
    function bidOnPartialCollateralLiquidation(uint256 newBid, uint256 hBTCQuantity, uint256 maxAcceptanceTimestamp) external {
        require(partialLiquidationInProgress, "no partial liquidation is in progress");
        require(block.timestamp <= maxAcceptanceTimestamp, "this bid is no longer valid based on the max acceptance timestamp");

        PartialLiquidation memory pl = partialLiquidationStatus[partialLiquidationCounter - 1];

        // Make sure that this bid is for a smaller amount of collateral
        require(newBid < pl.currentBidAmount, "new bid is not low enough");
        require(hBTCQuantity == pl.amountSatsToRecover, "amount of hBTC is incorrect");

        // Transfer the spedified amount of hBTC to this contract to submit a bona-fide bid
        bool transferResult = btcTokenContract.transferFrom(msg.sender, address(this), hBTCQuantity);
        require(transferResult, "specified hBTC count could not be collected");

        // Transfer the original hBTC back to the previous bidder
        bool returnTransferResult = btcTokenContract.transfer(pl.currentBidder, hBTCQuantity);
        require(returnTransferResult, "specified hBTC could not be returned to previous bidder"); // This should be impossible

        pl.currentBidAmount = newBid;
        pl.currentBidTime = block.timestamp;
        pl.currentBidder = msg.sender;
    }

    /**
    * Called by a partial liquidator when enough time has elapsed since the last bid for their bid to be accepted.
    * Transfers the bid-for amount of the collateral asset to the partial liquidator, and burns the collected hBTC.
    */
    function finalizePartialCollateralLiquidation() external {
        require(partialLiquidationInProgress, "no partial liquidation is in progress");

        PartialLiquidation memory pl = partialLiquidationStatus[partialLiquidationCounter - 1];
        require(pl.finished == false, "partial liquidation already completed");
        require(pl.currentBidTime + PARTIAL_LIQUIDATION_BID_TIME <= block.timestamp, "bid is not old enough");

        BitcoinTunnelManager mgr = BitcoinTunnelManager(tunnelAdmin);
        mgr.burnLiquidatedBTC(pl.amountSatsToRecover);

        vaultConfig.getPermittedCollateralAssetContract().transferFrom(address(this), pl.currentBidder, pl.currentBidAmount);
        depositedCollateralBalance = depositedCollateralBalance - pl.currentBidAmount;

        pl.finished = true;
        partialLiquidationInProgress = false;
    }

    /**
    * Begins a full collateral liquidation.
    *
    * If a pending liquidation is in progress, the pending liquidation is halted and the hBTC sent by the
    * current bidder is returned.
    *
    * The full collateral liquidation starts by setting an initial price for the collateral in hBTC, and
    * then over time the price increases.
    *
    * The liquidation must run for at least 4 hours (FULL_LIQUIDATION_DEPOSIT_GRACE_PERIOD) to allow
    * any straggler deposits to be processed and the corresponding hBTC also liquidated.
    */
    function beginFullCollateralLiquidation() external {
        // First, check the collateralization ratio
        IAssetPriceOracle oracle = vaultConfig.getPriceOracle();
        uint256 collateralUnitsToBTC = oracle.getAssetQuantityToBTC();

        if (!fullLiquidationAllowed) {
            // Get the value of the current deposited BTC priced in the collateral asset
            uint256 collateralCostOfDepositedBTC = collateralUnitsToBTC * totalDepositsHeld / 100_000_000; 

            uint256 collateralRatio = (depositedCollateralBalance * 100) / collateralCostOfDepositedBTC;
            if (collateralRatio >= vaultConfig.getHardCollateralizationThreshold()) {
                revert("no operator misbheavior and hard collateral threshold has not been surpassed");
            }
            fullLiquidationAllowed = true;
        }

        // Check if a partial liquidation is in progress, and if so stop it and return held bid funds
        if (partialLiquidationInProgress) {
                PartialLiquidation memory pl = partialLiquidationStatus[partialLiquidationCounter - 1];
                btcTokenContract.transferFrom(address(this), pl.currentBidder, pl.amountSatsToRecover);
                pl.finished = true;
                partialLiquidationInProgress = false;
        }

        // Vault liquidation is allowed, set the starting price to 5% higher than oracle reports,
        // and set starting timestamp for liquidation.
        fullLiquidationStarted = true;
        fullLiquidationStartTime = block.timestamp;
        fullLiquidationStartingPrice = (collateralUnitsToBTC * 105) / 100;
    }

    /**
    * Buys collateral in exchange for hBTC during a full liquidation process.
    *
    * The price that collateral is sold at is based on the starting price, updated based
    * on how long it has been since the liquidation process began.
    *
    * @param hBTCQuantity The quantity of hBTC the buyer wants to sell in exchange for collateral at the current price
    * @param recipient The recipient of the collateral. Optional, if not provided will default to msg.sender.
    */
    function purchaseCollateralDuringFullLiquidation(uint256 hBTCQuantity, address recipient) external {
        require(fullLiquidationStarted, "there is not an ongoing liquidation");

        if (recipient == address(0)) {
            recipient = msg.sender;
        }

        if (hBTCQuantity > totalDepositsHeld) {
            // Limit buyer to the amount of hBTC the vault needs to liquidate
            hBTCQuantity = totalDepositsHeld;
        }

        // First transfer hBTC from the buyer, then burn it.
        // We do not permit a direct call to a BitcoinTunnelManager function which can burn to ensure that a
        // vault implementation could not burn hBTC in an unauthorized manner.
        bool hBTCDepositSuccess = btcTokenContract.transferFrom(msg.sender, address(this), hBTCQuantity);
        require(hBTCDepositSuccess, "unable to transfer the specified amount of hBTC from the caller");

        BitcoinTunnelManager(tunnelAdmin).burnLiquidatedBTC(hBTCQuantity);

        uint256 currentPricePerBTC = getCurrentFullLiquidationCollateralPrice();
        uint256 collateralAmountOfSale = hBTCQuantity * currentPricePerBTC / 100_000_000;
        
        bool collateralTransferSuccess = vaultConfig.getPermittedCollateralAssetContract().transferFrom(address(this), recipient, collateralAmountOfSale);
        require (collateralTransferSuccess, "transferring collateral to the buyer failed");

        totalDepositsHeld = totalDepositsHeld - hBTCQuantity;
    }

    /**
    * Calculates the current price (in atomic units of collateral asset) per BTC (100M sats) based on
    * the current time versus when the liquidation was started.
    */
    function getCurrentFullLiquidationCollateralPrice() public view returns (uint256 collateralAtomicUnitsPerBTC) {
        uint256 secondsSinceLiquidationStart = block.timestamp - fullLiquidationStartTime;
        uint256 increasePerPeriod = fullLiquidationStartingPrice * FULL_LIQUIDATION_INCREASE_INCREMENT_BPS / 10000;
        uint256 incrementPeriods = secondsSinceLiquidationStart / FULL_LIQUIDATION_INCREASE_TIME;

        return fullLiquidationStartingPrice + (increasePerPeriod * incrementPeriods);
    }

    /**
    * Gets the net deposits of this vault, which is the total deposits held minus all pending withdrawals.
    */
    function getNetDeposits() public view returns (uint256) {
        return totalDepositsHeld - vaultStateChild.pendingWithdrawalAmountSat();
    }

    /**
    * Challenges a withdrawal, used by a withdrawer (via the BitcoinTunnel) to indicate that a withdrawal
    * was not processed by the vault as expected. If the challenge is successful (the vault agrees that
    * the withdrawal has not been processed as expected), it will return the number of sats to credit back
    * to the harmed withdrawer along with the withdrawer address these sats should be credited back to.
    *
    * For SimpleBitcoinVault, a withdrawal can be challenged successfully if more than the withdrawal grace
    * period has elapsed and the operator has not proven that the withdrawal has been fulfilled.
    *
    * @param uuid The uuid of the withdrawal to be challenged
    * @param extraInfo Arbitrary bytes that can contain additional data necessary to challenge if required by vault implementation.
    *
    * @return success Whether the challenge was successful (the vault did misbehave)
    * @return satsToCredit How many sats the harmed withdrawer should be re-credited with
    * @return withdrawer The EVM address of the harmed withdrawer who the satsToCredit should be credited to
    */
    function challengeWithdrawal(uint32 uuid, bytes memory extraInfo) external returns (bool success, uint256 satsToCredit, address withdrawer) {
        Withdrawal memory withdrawal = vaultStateChild.getWithdrawal(uuid);

        require(vaultStateChild.isWithdrawalFulfilled(uuid), "this withdrawal was already successfully processed");

        if (block.timestamp < withdrawal.timestampRequested + WITHDRAWAL_GRACE_PERIOD_SECONDS) {
            revert("the withdrawal grace period has not elapsed, and the operator can still process this withdrawal");
        }

        // The withdrawal has not been fulfilled and the time has elapsed, so sender should be credited with hBTC and the
        // vault needs to enter a full liquidation. Do not need to check if a full liquidation is already allowed or in progress
        // as it is a one-time latch.
        fullLiquidationAllowed = true;
        return (true, withdrawal.amount, withdrawal.evmOriginator);
    }


    /**
    * Returns whether the vault is currently accepting deposits.
    * For a SimpleBitcoinVault, deposits are always accepted if the vault is live.
    * This function does not check whether a deposit (of any size) is possible based on current collateral,
    * only whether the status of the vault is such that deposits will be accepted *if* collateral is
    * below the soft collateralization threshold for a particular deposit at the time of confirmation.
    *
    * @return acceptingDeposits Whether the vault is currently accepting deposits.
    */
    function isAcceptingDeposits() external view returns (bool acceptingDeposits) {
        return vaultStatus == Status.LIVE;
    }

    /**
    * Returns whether the vault is currently capable of processing another withdrawal.
    * This function returning true means that *some* withdrawal is possible, but does not
    * guarantee that a withdrawal of any particular size will be accepted.
    *
    * @return withdrawalAvailable Whether any withdrawal is currently possible
    */
    function isWithdrawalAvailable() external view returns (bool withdrawalAvailable) {
        if (vaultStatus == Status.LIVE || vaultStatus == Status.CLOSING_INIT) {
            uint256 available = vaultStateChild.pendingWithdrawalAmountSat() - depositedCollateralBalance;
            if (available > MINIMUM_WITHDRAWAL_SATS) {
                return true;
            }
            return false;
        }
        return false;
    }

    /**
    * Returns the lower and upper bounds of withdrawal amounts the vault will accept.
    * Function must revert if no withdrawal will be accepted.
    *
    * @return minWithdrawal The minimum amount in satoshis of a withdrawal the vault will currently accept
    * @return maxWithdrawal The maximum amount in satoshis of a withdrawal the vault will currently accept
    */
    function getWithdrawalLimits() external view returns (uint256 minWithdrawal, uint256 maxWithdrawal) {
        uint256 available = vaultStateChild.pendingWithdrawalAmountSat() - depositedCollateralBalance;
        if (available > MINIMUM_WITHDRAWAL_SATS) {
            return (MINIMUM_WITHDRAWAL_SATS, available);
        } else {
            return (0, 0);
        }
    }

}